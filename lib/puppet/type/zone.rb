#
# Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

Puppet::Type.newtype(:zone) do
  @doc = "Manages Solaris zones."

  module Puppet::Zone
    class StateMachine
      # A silly little state machine.
      def initialize
        @state = {}
        @sequence = []
        @state_aliases = {}
        @default = nil
      end

      # The order of calling insert_state is important
      def insert_state(name, transitions)
        @sequence << name
        @state[name] = transitions
      end

      def alias_state(state, salias)
        @state_aliases[state] = salias
      end

      def name(n)
        @state_aliases[n.to_sym] || n.to_sym
      end

      def index(state)
        @sequence.index(name(state))
      end

      # return all states between fs and ss excluding fs
      def sequence(fs, ss)
        fi = index(fs)
        si= index(ss)
        (if fi > si
        then @sequence[si .. fi].map{|i| @state[i]}.reverse
        else @sequence[fi .. si].map{|i| @state[i]}
         end)[1..-1]
      end

      def cmp?(a,b)
        index(a) < index(b)
      end
    end
  end

  ensurable do
    desc "The running state of the zone.  The valid states directly reflect
      the states that `zoneadm` provides.  The states are linear,
      in that a zone must be `configured`, then `installed`, and
      only then can be `running`.  Note also that `halt` is currently
      used to stop zones."

    def self.fsm
      return @fsm if @fsm
      @fsm = Puppet::Zone::StateMachine.new 
    end

    def self.alias_state(values)
      values.each do |k,v|
        fsm.alias_state(k,v)
      end
    end

    def self.seqvalue(name, hash)
      fsm.insert_state(name, hash)
      self.newvalue name
    end

    # This is seq value because the order of declaration is important.
    # i.e we go linearly from :absent -> :configured -> :installed -> :running
    seqvalue :absent, :down => :unconfigure
    seqvalue :configured, :up => :configure, :down => :uninstall
    seqvalue :installed, :up => :install, :down => :stop
    seqvalue :running, :up => :start

    alias_state(:incomplete => :installed,
                :ready => :installed,
                :shutting_down => :running,
                :unavailable => :down
               )

    defaultto :running

    def self.state_sequence(first, second)
      fsm.sequence(first, second)
    end

    # Why override it? because property/ensure.rb has a default retrieve method
    # that knows only about :present and :absent. That method just calls
    # provider.exists? and returns :present if a result was returned.
    def retrieve
      provider.properties[:ensure]
    end

    def provider_sync_send(method)
      warned = false
      while provider.processing?
        next if warned
        info "Waiting for zone to finish processing"
        warned = true
        sleep 1
      end
      provider.send(method)
    end

    def sync

      method = nil
      direction = up? ? :up : :down

      # We need to get the state we're currently in and just call
      # everything between it and us.
      self.class.state_sequence(self.retrieve, self.should).each do |state|
        method = state[direction]
        raise Puppet::DevError, "Cannot move #{direction} from #{st[:name]}" unless method
        provider_sync_send(method)
      end

      ("zone_#{self.should}").intern
    end

    # Are we moving up the property tree?
    def up?
      self.class.fsm.cmp?(self.retrieve, self.should)
    end

  end

  newparam(:name) do
    desc "The name of the zone."
    isnamevar
  end

  newparam(:config_profile) do
    desc "Path to the config_profile to use to configure a solaris zone.
          This is set when providing a sysconfig profile instead of running the
    sysconfig SCI tool on first boot of the zone."
  end

  newparam(:zonecfg_export) do
    desc "Contains the zone configuration information. This can be passed in
    in the form of a file generated by the zonecfg command, in the form
    of a template, or a string."
  end


  newparam(:zonecfg_archive) do
    desc "Archive to use to configure the zone.  Additional commands may be
    added via zonecfg_export."
  end

  newparam(:archive) do
    desc "The archive file (UAR) containing an archived zone."
  end

  newparam(:archived_zonename) do
    desc "If the UAR contains multiple zones. The archived zone to configure
    and install"
  end
  
  newparam(:clone) do
    desc "Instead of installing the zone, clone it from another zone.
      If the zone root resides on a zfs file system, a snapshot will be
      used to create the clone; if it resides on a ufs filesystem, a copy of the
      zone will be used. The zone from which you clone must not be running."
  end

  # Specify the sysidcfg file.  This is pretty hackish, because it's
  # only used to boot the zone the very first time.
  newparam(:sysidcfg) do
    desc %{The text to go into the `sysidcfg` file when the zone is first
      booted.  The best way is to use a template:

          # $confdir/modules/site/templates/sysidcfg.erb
          system_locale=en_US
          timezone=GMT
          terminal=xterms
          security_policy=NONE
          root_password=<%= password %>
          timeserver=localhost
          name_service=DNS {domain_name=<%= domain %> name_server=<%= nameserver %>}
          network_interface=primary {hostname=<%= realhostname %>
            ip_address=<%= ip %>
            netmask=<%= netmask %>
            protocol_ipv6=no
            default_route=<%= defaultroute %>}
          nfs4_domain=dynamic

      And then call that:

          zone { myzone:
            ip           => "bge0:192.168.0.23",
            sysidcfg     => template("site/sysidcfg.erb"),
            path         => "/opt/zones/myzone",
            realhostname => "fully.qualified.domain.name"
          }

      The `sysidcfg` only matters on the first booting of the zone,
      so Puppet only checks for it at that time.}
  end

  newparam(:install_args) do
    desc "Arguments to the `zoneadm` install command.  This can be used to create branded zones."
  end

  def retrieve
    hash = provider.properties
    return setstatus(hash) unless hash.nil? or hash[:ensure] == :absent
    # Return all properties as absent.
    return Hash[properties.map{|p| [p, :absent]} ]
  end

  # Take the results of a listing and set everything appropriately.
  def setstatus(hash)
    prophash = {}
    hash.each do |param, value|
      next if param == :name
      case self.class.attrtype(param)
      when :property
        # Only try to provide values for the properties we're managing
        prop = self.property(param)
        prophash[prop] = value if prop
      else
        self[param] = value
      end
    end
    prophash
  end

  # Private Properties
  # The following properties are used in conjunction with the "puppet resource zone"
  # output. They are valid properties for configuring a zone.

  newproperty(:id) do
    desc "The numerical ID of the zone.  This number is autogenerated
    and cannot be changed."
  end

  newproperty(:zonepath) do
    desc "The path to zone's file system."
  end

  newproperty(:iptype) do
    desc "Displays exclusive or shared instance of IP."
  end

  newproperty(:brand) do
    desc "The zone's brand type"
  end
end
